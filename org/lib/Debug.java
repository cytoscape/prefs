package org.lib;import java.io.PrintWriter;import java.io.StringWriter;public class Debug{	public static String describe(Object ov)	{return (ov == null) ? "null" : "'" + ov + "' // " + ov.getClass();	}//	static ILog logWriter;//	public static void setLog(ILog log)	{		logWriter = log;	}	//	static private boolean writeDebugs = true;	public static void p(String msg, Throwable ex) {		if (silent) return;		System.err.println(msg);		ex.printStackTrace();	}		public static void p(Throwable ex) {				System.err.println(ex.getLocalizedMessage());		ex.printStackTrace();	}	private static boolean silent = true;		public static void p(String msg) 					{		println(msg);	}	public static void p(String msg, Object...args) 	{		println(msg, args);	}	public static void println(String msg, Object...args)	{		if (silent) return;		String output = args.length > 0 ? String.format(msg.toString(), args) : msg;//		if (!AbstractServlet.isServletActive() && LogWindow.getInstance() != null && LogWindow.getInstance().isShowing())//			LogWindow.getInstance().println(msg);		System.out.println(output);	}//	public static void print(String msg, Object...args)//	{//		if (silent) return;//		String output = args.length > 0 ? String.format(msg, args) : msg;//		//Commented out the abstractServlet code. Print is not called anywhere and abstractservlet is the only thing blocking transfer of debug from //		//chimera to library -- aaron p//		if (/*!AbstractServlet.isServletActive() && */LogWindow.getInstance() != null && LogWindow.getInstance().isShowing())//			LogWindow.getInstance().print(output);//		System.out.print(output);//	}//	public static String exceptionToString(Throwable ex)	{		StringWriter stringWriter = new StringWriter();		PrintWriter printWriter = new PrintWriter(stringWriter);		ex.printStackTrace(printWriter);		return stringWriter.toString();	}	public static void printStackTrace(Throwable ex)	{ Debug.println(exceptionToString(ex));	}		public static void reportUnexpectedException(Exception e, String msg)		{ 		String cause = (e.getCause() != null) ? e.getCause().toString() : e.toString();			System.err.println(msg + ": " + cause);	}	public static void printStack(String msg)	{//		try//		{//			System.out.println(msg);//			throw new RuntimeException(msg);//		}//		catch (Exception ex)		{ex.printStackTrace(); }		if (silent) return;		System.err.println(msg);		(new Throwable()).printStackTrace();	}		public static void st(String msg) {		printStack(msg);	}	static private final boolean DO_TRACE = true;    static private final boolean DO_TIME = false;//    static private long lastTime = System.currentTimeMillis();    static private long startTime = System.currentTimeMillis();    static public void trace(String msg)    {     if (DO_TRACE)         showTime(msg);    }//    public static void startLogging()    	{        LogWindow.pop();    }     static public void showTime(String msg)    {        if (!DO_TIME || silent)         return;         long currTime = System.currentTimeMillis();         String time = Long.toString(100000 + currTime - startTime);      // cheezy formating for a nn.nnn time stamp        StringBuffer buf = new StringBuffer(time);        System.out.println(buf.substring(1, 3) + "." + buf.substring(3, 6) + " " + msg);//        lastTime = currTime;   }	/** Show the amount of memory this process is using.	 * T: indicates memory allocated from the operating system.	 * U: indicates memory currently needed by the process.	 * DU: indicates the change in U: memory since the last call.	 */	private static long lastUsed = 0;	public static void showMemory(String msg)	{	    Runtime rt = Runtime.getRuntime();	    long total = rt.totalMemory();	    long used = rt.totalMemory() - rt.freeMemory();	    long diff = used - lastUsed;	    println(msg  + " T: " + (total / 1000.0) + " U: " + (used / 1000.0) + " DU: " + (diff / 1000.0));	    lastUsed = used;	}	//	public static void println(SElement elem)	{	println(elem.getXMLString());			}}